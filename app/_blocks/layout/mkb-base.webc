<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"> -->
  <title>Мир комфорта и безопасности - mkb.by</title>
  <meta name="description" content="Мир комфорта и безопасности - mkb.by">
  <!-- favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="manifest" href="/assets/site.webmanifest">
  <link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <!-- scripts -->
  <link rel="stylesheet" href="/styles/main.css" webc:keep>
  <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU" webc:if="isMap" defer webc:keep></script>
  <script src="/scripts/main.js" defer webc:keep></script>
</head>
<body
  v-scope
  v-on:mounted="store.mounted"
>
  <mkb-header-with-breadcrumbs
    webc:if="header?.withBreadcrumbs"
    :header="header"
  ></mkb-header-with-breadcrumbs>
  <mkb-header webc:else :header="header"></mkb-header>

  <main class="main">
    <slot></slot>
  </main>

  <mkb-footer :is-footer="isFooter"></mkb-footer>

  <mkb-callback-modal></mkb-callback-modal>

  <mkb-thanks-modal></mkb-thanks-modal>

  <mkb-desktop-menu></mkb-desktop-menu>

  <mkb-mobile-menu></mkb-mobile-menu>

  <script webc:keep type="module">
    import { createApp, reactive } from 'https://unpkg.com/petite-vue@0.2.2/dist/petite-vue.es.js';
    import lodash from 'https://cdn.jsdelivr.net/npm/lodash@4.17.21/+esm';

    const store = reactive({
      isCallbackModalShow: false,
      isThanksModalShow: false,
      isMobileCatalogFilterShow: false,
      isDesktopMenuShow: false,
      isMobileMenuShow: false,
      isSubmenuInMobileMenuShow: false,
      toggleMobileCatalogFilter(state) {
        if (state === 'open') {
          this.isMobileCatalogFilterShow = true;
          document.body.classList.add('lock');
        } else {
          this.isMobileCatalogFilterShow = false;
          document.body.classList.remove('lock');
        }
      },
      mounted() {
        const header = document.querySelector('.header');

        if (!header) return;

        function changeColorHeader() {
          if (window.pageYOffset > 0) {
            header.classList.add('active');
          } else {
            header.classList.remove('active');
          }
        }

        window.addEventListener('scroll', lodash.throttle(changeColorHeader, 150));
      }
    });

    function Form() {
      return {
        formData: {
          name: {
            value: '',
            isError: false,
            regExp: /[а-яА-Я]+/,
            errorMessage: 'Поле является обязательным. Допускается ввод букв русского алфавита.',
          },
          phone: {
            value: '',
            isError: false,
            regExp: /./,
            errorMessage: 'Поле является обязательным.',
            // regExp: /^\+375\d{9}$/,
            // errorMessage: 'Поле является обязательным. Ввведите телефон в следующем формате: +375XXXXXXXXX',
          },
          comment: {
            value: '',
            isError: false,
            regExp: /./,
            errorMessage: 'Поле является обязательным.',
          },
        },
        validateInput(type) {
          const dataElement = this.formData[type];

          if (!dataElement.value.match(dataElement.regExp)) {
            dataElement.isError = true;
          } else {
            dataElement.isError = false;
          }
        },
        async fetchData(form) {
          try {
            const response = await fetch(form.action, {
              method: 'POST',
              headers: {
                'Content-Type': 'multipart/form-data'
              },
              body: new FormData(form),
            });

            if (!response.ok) {
              throw new Error(`HTTP error. Status: ${response.status}`);
            }

            const result = await response.json();

            if (!result.status) return;

            form.reset();
            store.isCallbackModalShow = false;
            store.isThanksModalShow = true;
          } catch (error) {
            console.error(error);
            form.reset();
            store.isCallbackModalShow = false;
          }
        },
        onFormSubmit() {
          const form = this.$refs.form;
          const arrayFormData = Object.entries(this.formData);
          arrayFormData.forEach((formData) => {
            this.validateInput(formData[0]);
          });

          if (arrayFormData.find((formData) => formData[1].isError)) {
            return;
          }

          this.fetchData(form);
        }
      }
    }

    createApp({
      Form,
      store
    }).mount();
  </script>
</body>
</html>